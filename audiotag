#!/usr/bin/perl

use strict;
use warnings;
use File::Spec;
use Getopt::Long;

our $VERSION = 0.7;
our $PROGRAM = "Audiotag";

our $COPYRIGHT = <<COPYRIGHT;
Written by Ryan McGuigan

Copyright (C) 2003 Ryan McGuigan
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
COPYRIGHT

our $insane_error = "";
our $help = 0;
our $pretend = 0;
our $gt = 0;
our $track_pattern = '';
our $track = '';
our $force_track = 0;
our $genre = '';
our $genre_pattern = '';
our $artist = '';
our $artist_pattern = '';
our $album = '';
our $album_pattern = '';
our $title = '';
our $title_pattern = '';
our $force_title = 0;
our $list_info = 0;
our $display_version = 0;
our $recursive = 0;
our $recursive_noted = 0;

our %id3_names = (
	# long id?
	TCON => "GENRE",
	TRCK => "TRACKNUM",
	TALB => "ALBUM",
	TPE1 => "ARTIST",
	TIT2 => "TITLE",

	# short id?
	TCO => "GENRE",
	TRK => "TRACKNUM",
	TAL => "ALBUM",
	TP1 => "ARTIST",
	TT2 => "TITLE"
);

# I grabbed these from id3lib - I hope they're correct
our %id3_genres = (
	"Blues" => 0,
	"Classic Rock" => 1,
	"Country" => 2,
	"Dance" => 3,
	"Disco" => 4,
	"Funk" => 5,
	"Grunge" => 6,
	"Hip-Hop" => 7,
	"Jazz" => 8,
	"Metal" => 9,
	"New Age" => 10,
	"Oldies" => 11,
	"Other" => 12,
	"Pop" => 13,
	"R&B" => 14,
	"Rap" => 15,
	"Reggae" => 16,
	"Rock" => 17,
	"Techno" => 18,
	"Industrial" => 19,
	"Alternative" => 20,
	"Ska" => 21,
	"Death Metal" => 22,
	"Pranks" => 23,
	"Soundtrack" => 24,
	"Euro-Techno" => 25,
	"Ambient" => 26,
	"Trip-Hop" => 27,
	"Vocal" => 28,
	"Jazz+Funk" => 29,
	"Fusion" => 30,
	"Trance" => 31,
	"Classical" => 32,
	"Instrumental" => 33,
	"Acid" => 34,
	"House" => 35,
	"Game" => 36,
	"Sound Clip" => 37,
	"Gospel" => 38,
	"Noise" => 39,
	"AlternRock" => 40,
	"Bass" => 41,
	"Soul" => 42,
	"Punk" => 43,
	"Space" => 44,
	"Meditative" => 45,
	"Instrumental Pop" => 46,
	"Instrumental Rock" => 47,
	"Ethnic" => 48,
	"Gothic" => 49,
	"Darkwave" => 50,
	"Techno-Industrial" => 51,
	"Electronic" => 52,
	"Pop-Folk" => 53,
	"Eurodance" => 54,
	"Dream" => 55,
	"Southern Rock" => 56,
	"Comedy" => 57,
	"Cult" => 58,
	"Gangsta" => 59,
	"Top 40" => 60,
	"Christian Rap" => 61,
	"Pop/Funk" => 62,
	"Jungle" => 63,
	"Native American" => 64,
	"Cabaret" => 65,
	"New Wave" => 66,
	"Psychadelic" => 67,
	"Rave" => 68,
	"Showtunes" => 69,
	"Trailer" => 70,
	"Lo-Fi" => 71,
	"Tribal" => 72,
	"Acid Punk" => 73,
	"Acid Jazz" => 74,
	"Polka" => 75,
	"Retro" => 76,
	"Musical" => 77,
	"Rock & Roll" => 78,
	"Hard Rock" => 79,
	# winamp extentions below
	"Folk" => 80,
	"Folk-Rock" => 81,
	"National Folk" => 82,
	"Swing" => 83,
	"Fast Fusion" => 84,
	"Bebob" => 85,
	"Latin" => 86,
	"Revival" => 87,
	"Celtic" => 88,
	"Bluegrass" => 89,
	"Avantgarde" => 90,
	"Gothic Rock" => 91,
	"Progressive Rock" => 92,
	"Psychedelic Rock" => 93,
	"Symphonic Rock" => 94,
	"Slow Rock" => 95,
	"Big Band" => 96,
	"Chorus" => 97,
	"Easy Listening" => 98,
	"Acoustic" => 99,
	"Humour" => 100,
	"Speech" => 101,
	"Chanson" => 102,
	"Opera" => 103,
	"Chamber Music" => 104,
	"Sonata" => 105,
	"Symphony" => 106,
	"Booty Bass" => 107,
	"Primus" => 108,
	"Porn Groove" => 109,
	"Satire" => 110,
	"Slow Jam" => 111,
	"Club" => 112,
	"Tango" => 113,
	"Samba" => 114,
	"Folklore" => 115,
	"Ballad" => 116,
	"Power Ballad" => 117,
	"Rhythmic Soul" => 118,
	"Freestyle" => 119,
	"Duet" => 120,
	"Punk Rock" => 121,
	"Drum Solo" => 122,
	"A capella" => 123,
	"Euro-House" => 124,
	"Dance Hall" => 125,
	"Goa" => 126,
	"Drum & Bass" => 127,
	"Club-House" => 128,
	"Hardcore" => 129,
	"Terror" => 130,
	"Indie" => 131,
	"Britpop" => 132,
	"Negerpunk" => 133,
	"Polsk Punk" => 134,
	"Beat" => 135,
	"Christian Gangsta Rap" => 136,
	"Heavy Metal" => 137,
	"Black Metal" => 138,
	"Crossover" => 139,
	"Contemporary Christian" => 140,
	"Christian Rock " => 141,
	"Merengue" => 142,
	"Salsa" => 143,
	"Trash Metal" => 144,
	"Anime" => 145,
	"JPop" => 146,
	"Synthpop" => 147,
);

our %id3_genres_UC;
foreach (keys %id3_genres) { $id3_genres_UC{uc $_} = $id3_genres{$_} }

our %id3_genre_ids;
foreach (keys %id3_genres) { $id3_genre_ids{$id3_genres{$_}} = $_ }

sub Usage {
	print <<USAGE;
Usage: $0 [OPTION]... [FILE]...
Set id3 and/or vorbis tags in mp3 and/or ogg files.

Option:
  -G, --guesstrack              guess the track number (guess uses a simple
                                  pattern match of the filename, /(\\d\\d)\\./)
  -T, --track=TRACK             set the track to TRACK
      --track-pattern=PATTERN   extract the track number from the filename
                                  using perl compatible regex PATTERN
  -g, --genre=GENRE             set the genre to GENRE
      --genre-pattern=PATTERN   extract the genre from the filename using perl
                                  compatible regex PATTERN
  -a, --artist=ARTIST           set the artist to ARTIST
      --artist-pattern=PATTERN  extract the artist name from the filename using
                                  perl compatible regex PATTERN
  -t, --title=TITLE             set the title to TITLE
      --title-pattern=PATTERN   extract the title from the filename using perl
                                  compatible regex PATTERN
  -l, --list-info               list track info
  -r, --recursive               descend into directories recursively
  -p, --pretend                 show what WOULD have been done had --pretend
                                  not been used
  -h, --help                    display this help and exit
  -V, --version                 output version information and exit
USAGE
	return 1;
}

sub set_tag {
	my ($file) = @_;
	my @cmd;
	my %info;
	my @result;
	my %plus_tags;
	my $_pretend = $pretend ? "I would be " : "";

	# reset vars in case we get no match
	if ($gt) { $track = "" }
	if ($track_pattern) { $track = "" }
	if ($title_pattern) { $title = "" }
	if ($artist_pattern) { $artist = "" }
	if ($album_pattern) { $album = "" }
	if ($genre_pattern) { $genre = "" }

	if ($track_pattern && $file =~ /$track_pattern/) { $track = $1 }
	if ($title_pattern && $file =~ /$title_pattern/) { $title = $1 }
	if ($artist_pattern && $file =~ /$artist_pattern/) { $artist = $1 }
	if ($album_pattern && $file =~ /$album_pattern/) { $album = $1 }
	if ($genre_pattern && $file =~ /$genre_pattern/) { $genre = $1 }
	
	if ($file =~ /\.ogg$/i) { %info = get_vorbis_info($file) }
	elsif ($file =~ /\.mp3$/i) { %info = get_mp3_info($file) }
	else {
		print STDERR "$file: the filename must end in .ogg or .mp3\n";
		return;
	}

	if ($gt && $file =~ /(\d\d)\./) { $track = $1 }
	if ($genre) { $plus_tags{"GENRE"} = "+++"; $info{"GENRE"} = $genre }
	if ($artist) { $plus_tags{"ARTIST"} = "+++";  $info{"ARTIST"} = $artist }
	if ($album) { $plus_tags{"ALBUM"} = "+++";  $info{"ALBUM"} = $album }
	if ($title) { $plus_tags{"TITLE"} = "+++";  $info{"TITLE"} = $title }
	if ($track) { $plus_tags{"TRACKNUM"} = $plus_tags{"TRACKNUMBER"} = "+++";
		$info{"TRACKNUM"} = $info{"TRACKNUMBER"} = $track }

	if ($file =~ /\.ogg$/i) {
		push @cmd, "vorbiscomment";
		push @cmd, "-w";

		foreach (sort { $a cmp $b } keys %info) {
			$plus_tags{$_} ||= "===";
			push @result, "$plus_tags{$_} $_=$info{$_}";
			push @cmd, "-t", "$_=$info{$_}"
		}
		push @cmd, $file;
	}
	elsif ($file =~ /\.mp3$/i) {
		push @cmd, "id3tag";
		foreach (sort { $a cmp $b } keys %info) {
			# don't need extra track num field
			/TRACKNUMBER/ && next;
			$plus_tags{$_} ||= "===";
			push @result, "$plus_tags{$_} $_=$info{$_}";
		}
		if ($genre) { push @cmd, "--genre=" . $id3_genres_UC{uc $genre} }
		if ($artist) { push @cmd, "--artist=" . $artist }
		if ($album) { push @cmd, "--album=" . $album }
		if ($title) { push @cmd, "--song=" .  $title }
		if ($track) { push @cmd, "--track=" . $track }
		push @cmd, $file;
	}

	print "\n", $_pretend, "*** tagging \`$file'\n", join("\n", @result), "\n";
	unless ($pretend) { quiet_system(@cmd) }
}

sub get_vorbis_info {
	my ($file) = @_;
	my %info;

	# fixed! done elsewhere - FIXME - gracefully handle missing `vorbiscomment'
	foreach (split /\n/, `vorbiscomment "$file"`) {
		if (/(.*?)=(.*)/) {
			$info{ uc $1 } = $2;
		}
	}

	return %info;
}

sub get_mp3_info {
	my ($file) = @_;
	my %info;

	# fixed! done elsewhere - FIXME - gracefully handle missing `id3info'
	foreach (split /\n/, `id3info "$file"`) {
		if (/=== ([A-Z0-9]{3,4}) \(.*?\): (.*)/) {
			if ($id3_names{$1}) { $info{ $id3_names{$1} } = $2 }
		}
	}

	if ($info{"GENRE"} && $info{"GENRE"} =~ /\((\d+)\)/)
	{ $info{"GENRE"} = $id3_genre_ids{$1} }

	return %info;
}

sub quiet_system {
	my (@cmd) = @_;
	my $oldout;
	my $olderr;
	my $retval;

	# save stdout and stderr
	open $oldout, ">&STDOUT" or warn "Can't dup STDOUT: $!\n";
	open $olderr, ">&STDOUT" or warn "Can't dup STDOUT: $!\n";

	open STDOUT, ">", File::Spec->devnull() or warn "No null device?: $!\n";
	open STDERR, ">&STDOUT" or warn "Can't dup STDOUT: $!\n";

	select STDOUT; $| = 1;
	select STDERR; $| = 1;

	# MUST BE FIXED BEFORE 1.0!!!
	# FIXME - we should capture stdout/err for the user in case of a problem
	$retval = system(@cmd);

	close STDOUT;
	close STDERR;

	# restore stdout and stderr
	open STDOUT, ">&", $oldout or die "Can't restore STDOUT!: $!\n";
	open STDERR, ">&", $olderr or die "Can't restore STDERR!: $!\n";

	return $retval;
}

sub descend_into {
	my (@dirs) = @_;
	my @files;

	while (local $_ = shift @dirs) {
		# FIXME - must check for recursive symlinks before
		# implementing symlink traversal
		if (-l $_) { print "FIXME - I don't handle symlinks yet.  sorry...\n" }
		elsif (opendir DIR, $_) {
			foreach my $dirent (grep !/^\./, readdir DIR) {
				# FIXME? - we're assuming catfile will work for files and
				# dirs, but on some (non-Unix) platforms this may not be
				# the case.  do we give a flying fuck about non-Unix
				# platforms anyway?  probably not.
				$dirent = File::Spec->catfile($_, $dirent);
				if (-d $dirent) { push @dirs, $dirent }
				elsif ($dirent =~ /(\.ogg|\.mp3)$/i) { push @files, $dirent }
			}
		}
		else { warn "can't open dir \`$_': $!\n" }
	}

	return @files;
}

sub sane {
	my $retval = 1;
	my @missing;

	foreach ("vorbiscomment", "id3info", "id3tag") {
		unless ( which($_) ) {
			$retval = 0;
			push @missing, "\`$_'";
		}
	}

	@missing > 1 and $missing[-1] = "\b\b and $missing[-1]";
	$retval or $insane_error = join(", ", @missing) . " not found in path!";

	return $retval;
}

sub which {
	my ($prog) = @_;
	my @paths = split ":", $ENV{"PATH"};
	my $progpath;

	foreach (@paths) {
		$progpath = File::Spec->catfile($_, $prog);
		if (-x $progpath) { return $progpath }
	}

	return undef;
}

main: {
	my @files;

	sane() or die "Failed sanity check: $insane_error\n";

	Getopt::Long::Configure ("bundling");
	GetOptions(
		'guesstrack|G' => \$gt,
		'track|T=s' => \$track,
		'track-pattern=s' => \$track_pattern,
		'genre|g=s' => \$genre,
		'genre-pattern=s' => \$genre_pattern,
		'artist|a=s' => \$artist,
		'artist-pattern=s' => \$artist_pattern,
		'album|A=s' => \$album,
		'album-pattern=s' => \$album_pattern,
		'title|t=s' => \$title,
		'title-pattern=s' => \$title_pattern,
		'pretend|p' => \$pretend,
		'force-title' => \$force_title,
		'force-track' => \$force_track,
		'recursive|r' => \$recursive,
		'list-info|l' => \$list_info,
		'version|V' => \$display_version,
		'help|h' => \$help,
	) or exit Usage();

	if ($help) {
		Usage();
	}
	elsif ($display_version) {
		print "$PROGRAM $VERSION\n$COPYRIGHT";
	}
	elsif (@ARGV && ( $gt || $list_info || $track || $genre || $artist
		|| $album || $title || $title_pattern || $artist_pattern
		|| $album_pattern || $genre_pattern || $track_pattern ) )
	{
		if (!$force_title && $title && (@ARGV > 1)) {
			print <<WTF;

It does not make much sense to tag multiple files with the same title.  That's
probably not what you meant to do, so I'm stopping now.  If I'm mistaken, and
you really do want to tag multiple files with the same title, pass the
(undocumented) --force-title option.

WTF
			exit 1;
		}
		if (!$force_track && $track && (@ARGV > 1)) {
			print <<WTF;

It does not make much sense to tag multiple files with the same track number.
That's probably not what you meant to do, so I'm stopping now.  If I'm
mistaken, and you really do want to tag multiple files with the same track
number, pass the (undocumented) --force-track option.

WTF
			exit 1;
		}
		@files = @ARGV;

		while (local $_ = shift @files) {
			if (-e) {
				if (-l) {
					# FIXME - must check for recursive symlinks before
					# implementing symlink traversal
					print "FIXME - I don't handle symlinks yet.  sorry...\n";
				}
				elsif (-d) {
					if ($recursive) { push @files, descend_into($_) }
					else {
						unless ($recursive_noted) {
							$recursive_noted = 1;
							print <<WTF;

Pass the --recursive option if you want to descend into directories.

WTF
							sleep 2;
						}
					}
				}
				else {
					if ($list_info) {
						my %info;
						my @info;

						if ($_ =~ /\.(ogg|mp3)$/i) {
							if ($_ =~ /\.ogg$/i) {
								%info = get_vorbis_info($_);
							}
							elsif ($_ =~ /\.mp3$/i) {
								%info = get_mp3_info($_);
							}
							foreach (sort { $a cmp $b } keys %info)
							{ push @info, "=== $_: $info{$_}" }
							print "\n*** \`$_'\n", join("\n", @info), "\n";
						}
					}
					else { set_tag($_) }
				}
			}
			else { print "I don't see any file or directory by the name \`$_'\n" }
		}
	}
	else {
		exit Usage();
	}
}

